===============================
Chapter 2: Finite Automata
===============================

.. rubric:: 🎯 Learning Objectives

By the end of this chapter, you will be able to:

* Define and construct Deterministic Finite Automata (DFA)
* Build Nondeterministic Finite Automata (NFA) 
* Convert NFAs to DFAs using subset construction
* Design automata for specific language requirements
* Prove language acceptance using formal methods

----

**📋 Prerequisites**
====================

.. note::
   
   **Essential:** Basic set theory, function definitions
   
   **Helpful:** Graph theory basics, state-based thinking

----

**1. Theory & Formal Definitions**
==================================

**1.1 Deterministic Finite Automaton (DFA)**
---------------------------------------------

A **DFA** is a 5-tuple: **M = (Q, Σ, δ, q₀, F)**

Where:

* **Q** = finite set of states
* **Σ** = finite input alphabet  
* **δ: Q × Σ → Q** = transition function
* **q₀ ∈ Q** = start state
* **F ⊆ Q** = set of accept (final) states

**1.2 Language of a DFA**
-------------------------

The **language L(M)** accepted by DFA M is:

.. math::
   
   L(M) = \{w \in \Sigma^* \mid \hat{\delta}(q_0, w) \in F\}

Where **δ̂** is the extended transition function.

**1.3 Nondeterministic Finite Automaton (NFA)**
-----------------------------------------------

An **NFA** is a 5-tuple: **N = (Q, Σ, δ, q₀, F)**

Key difference: **δ: Q × Σ → 2^Q** (transitions to subsets of states)

----

**2. Construction Examples**
============================

**Example 1: DFA for Binary Strings Ending in "01"**
----------------------------------------------------

**Problem:** Design a DFA that accepts all binary strings ending with "01".

**Solution Strategy:**
1. Track the last two characters seen
2. Use states to remember: nothing, last was 0, last was 1, last two were 01

.. code-block:: text

   States: Q = {q₀, q₁, q₂, q₃}
   Alphabet: Σ = {0, 1}
   Start state: q₀
   Accept states: F = {q₂}
   
   State meanings:
   q₀: initial state / last char was 1
   q₁: last character was 0  
   q₂: last two characters were 01 (ACCEPT)
   q₃: dead state (not used in this example)

**Transition Function δ:**

.. code-block:: text

   δ(q₀, 0) = q₁
   δ(q₀, 1) = q₀
   δ(q₁, 0) = q₁  
   δ(q₁, 1) = q₂
   δ(q₂, 0) = q₁
   δ(q₂, 1) = q₀

**State Diagram:**

.. code-block:: text

          0        1
   →q₀ -----→ q₁ -----→ ((q₂))
    ↑  ↖1      ↑0       ↙0
    └────────────────────┘

**Example 2: NFA with ε-transitions**
------------------------------------

**Problem:** Build an NFA that accepts strings containing "ab" or "ba" as substrings.

.. code-block:: text

   This requires parallel computation paths:
   Path 1: Looking for "ab"
   Path 2: Looking for "ba"
   
   States: {q₀, q₁, q₂, q₃, q₄, q₅}
   
   q₀: start state
   q₁, q₂: tracking "ab" pattern  
   q₃, q₄: tracking "ba" pattern
   q₅: accept state (found either pattern)

----

**3. Practice Exercises**
=========================

**Exercise 1: DFA Construction**
-------------------------------

Design a DFA that accepts all strings over {0,1} with an even number of 0s and an odd number of 1s.

.. hint::
   
   **💡 Hint:** 
   
   * You need to track two properties simultaneously
   * Use 4 states: (even 0s, even 1s), (even 0s, odd 1s), etc.
   * Think about which state should be the accept state

.. admonition:: Solution
   :class: dropdown

   .. code-block:: text

      States: Q = {q₀₀, q₀₁, q₁₀, q₁₁}
      where qᵢⱼ means: i = parity of 0s, j = parity of 1s
      (0 = even, 1 = odd)
      
      Start state: q₀₀ (even 0s, even 1s)
      Accept state: F = {q₀₁} (even 0s, odd 1s)
      
      Transitions:
      δ(q₀₀, 0) = q₁₀    δ(q₀₀, 1) = q₀₁
      δ(q₀₁, 0) = q₁₁    δ(q₀₁, 1) = q₀₀  
      δ(q₁₀, 0) = q₀₀    δ(q₁₀, 1) = q₁₁
      δ(q₁₁, 0) = q₀₁    δ(q₁₁, 1) = q₁₀
      
      State Diagram:
               0           1
      →q₀₀ ⟷ q₁₀     q₀₀ ⟷ ((q₀₁))
         ↑↓ 1   ↑↓ 1      ↑↓ 0   ↑↓ 0  
       q₀₁ ⟷ q₁₁     q₁₀ ⟷ q₁₁
           0           1

**Exercise 2: NFA to DFA Conversion**
------------------------------------

Convert the following NFA to an equivalent DFA using subset construction:

.. code-block:: text

   NFA N = ({q₀, q₁, q₂}, {a, b}, δ, q₀, {q₂})
   
   δ(q₀, a) = {q₀, q₁}
   δ(q₀, b) = {q₀}
   δ(q₁, a) = ∅
   δ(q₁, b) = {q₂}
   δ(q₂, a) = ∅  
   δ(q₂, b) = ∅

.. hint::
   
   **💡 Hint:** 
   
   * Start with {q₀}
   * For each subset, compute transitions on each input symbol
   * A subset is accepting if it contains any accepting state from the NFA
   * Continue until no new subsets are generated

.. admonition:: Solution  
   :class: dropdown

   .. code-block:: text

      Step-by-step subset construction:
      
      Start: {q₀}
      
      From {q₀}:
      - on 'a': δ(q₀, a) = {q₀, q₁}
      - on 'b': δ(q₀, b) = {q₀}
      
      From {q₀, q₁}:
      - on 'a': δ(q₀, a) ∪ δ(q₁, a) = {q₀, q₁} ∪ ∅ = {q₀, q₁}
      - on 'b': δ(q₀, b) ∪ δ(q₁, b) = {q₀} ∪ {q₂} = {q₀, q₂}
      
      From {q₀, q₂}:
      - on 'a': δ(q₀, a) ∪ δ(q₂, a) = {q₀, q₁} ∪ ∅ = {q₀, q₁}
      - on 'b': δ(q₀, b) ∪ δ(q₂, b) = {q₀} ∪ ∅ = {q₀}
      
      DFA states: {{q₀}, {q₀, q₁}, {q₀, q₂}}
      Accept states: {{q₀, q₂}} (contains q₂)
      
      Final DFA:
      States: {A, B, C} where A={q₀}, B={q₀,q₁}, C={q₀,q₂}
      Start: A
      Accept: {C}
      
      Transitions:
      δ(A, a) = B    δ(A, b) = A
      δ(B, a) = B    δ(B, b) = C  
      δ(C, a) = B    δ(C, b) = A

**Exercise 3: Language Design**
------------------------------

Design a DFA that accepts the language L = {w ∈ {a,b}* | w has substring "aba"}.

.. hint::
   
   **💡 Hint:** 
   
   * Track progress toward finding "aba"
   * States should represent: seen nothing useful, seen "a", seen "ab", seen "aba"
   * Once you've seen "aba", you accept regardless of what follows

.. admonition:: Solution
   :class: dropdown

   .. code-block:: text

      Strategy: Track the longest prefix of "aba" that matches a suffix of the input read so far.
      
      States: {q₀, q₁, q₂, q₃}
      q₀: no useful progress toward "aba"
      q₁: last character was 'a' (potential start of "aba")  
      q₂: last two characters were "ab"
      q₃: found "aba" - accept state
      
      Start: q₀
      Accept: F = {q₃}
      
      Transitions:
      δ(q₀, a) = q₁    δ(q₀, b) = q₀
      δ(q₁, a) = q₁    δ(q₁, b) = q₂
      δ(q₂, a) = q₃    δ(q₂, b) = q₀  
      δ(q₃, a) = q₁    δ(q₃, b) = q₀
      
      Note: From q₃, we still need to track for more "aba" patterns
      
      Example trace for "aababa":
      q₀ --a--> q₁ --a--> q₁ --b--> q₂ --a--> q₃ --b--> q₀ --a--> q₁
      Final state q₁ ∉ F, but we passed through q₃, so... 
      
      Wait - let me reconsider. Once in q₃, we stay accepting:
      
      Better design:
      δ(q₃, a) = q₃    δ(q₃, b) = q₃
      
      Or track ongoing patterns while staying accepting.

----

**4. Video Resources**
======================

.. raw:: html

   <div style="margin: 20px 0;">
   <h3>📺 Finite Automata Fundamentals</h3>
   <video controls autoplay muted width="100%" style="max-width: 800px;">
     <source src="_static/videos/finite_automata_intro.mp4" type="video/mp4">
     <p>Your browser does not support the video tag.</p>
   </video>
   <p><em>Video: Introduction to DFAs and NFAs - Definitions and Basic Construction (25 minutes)</em></p>
   </div>

.. raw:: html

   <div style="margin: 20px 0;">
   <h3>🎥 Subset Construction Algorithm</h3>
   <video controls width="100%" style="max-width: 800px;">
     <source src="_static/videos/nfa_to_dfa_conversion.mp4" type="video/mp4">
     <p>Your browser does not support the video tag.</p>
   </video>
   <p><em>Video: Step-by-step NFA to DFA conversion with worked examples (20 minutes)</em></p>
   </div>

----

**5. Summary & Key Takeaways**
==============================

.. admonition:: 🎓 Chapter Summary
   :class: tip

   **Core Concepts Mastered:**
   
   * ✅ **DFA Definition** - 5-tuple components and their roles
   * ✅ **NFA Definition** - Nondeterminism and ε-transitions  
   * ✅ **Language Acceptance** - Formal definition using extended δ
   * ✅ **Construction Techniques** - Systematic automata design
   * ✅ **Equivalence** - NFA to DFA conversion algorithms
   
   **Problem-Solving Skills:**
   
   * 🔧 Designing automata for specific language requirements
   * 🔧 Tracking multiple properties with state combinations
   * 🔧 Converting between deterministic and nondeterministic models
   * 🔧 Proving correctness of automata constructions

**Important Theorems:**

.. admonition:: 📚 Key Results
   :class: note

   * **Theorem 2.1:** Every NFA has an equivalent DFA
   * **Theorem 2.2:** The regular languages are closed under union, concatenation, and Kleene star
   * **Theorem 2.3:** A language is regular if and only if it is accepted by some finite automaton

----

**Next Steps**
==============

.. note::
   
   **🚀 Ready for Regular Expressions?**
   
   In Chapter 3, we'll explore:
   * Regular expression syntax and semantics
   * Equivalence between regular expressions and finite automata
   * Converting between representations
   * Pumping lemma for regular languages
   
   :doc:`Continue to Regular Expressions → <regular_expressions>`

.. admonition:: Self-Check
   :class: important

   **Before proceeding, ensure you can:**
   
   * [ ] Draw DFAs and NFAs for given language descriptions
   * [ ] Execute automata on input strings step-by-step
   * [ ] Convert NFAs to equivalent DFAs systematically  
   * [ ] Prove that an automaton accepts a specific language
   
   **Need more practice?** Try the additional exercises in :doc:`solutions_manual`

===============================
Chapter 2: Finite Automata
===============================

.. rubric:: ğŸ¯ Learning Objectives

By the end of this chapter, you will be able to:

* Define and construct Deterministic Finite Automata (DFA)
* Build Nondeterministic Finite Automata (NFA) 
* Convert NFAs to DFAs using subset construction
* Design automata for specific language requirements
* Prove language acceptance using formal methods

----

**ğŸ“‹ Prerequisites**
====================

.. note::
   
   **Essential:** Basic set theory, function definitions
   
   **Helpful:** Graph theory basics, state-based thinking

----

**1. Theory & Formal Definitions**
==================================

**1.1 Deterministic Finite Automaton (DFA)**
---------------------------------------------

A **DFA** is a 5-tuple: **M = (Q, Î£, Î´, qâ‚€, F)**

Where:

* **Q** = finite set of states
* **Î£** = finite input alphabet  
* **Î´: Q Ã— Î£ â†’ Q** = transition function
* **qâ‚€ âˆˆ Q** = start state
* **F âŠ† Q** = set of accept (final) states

**1.2 Language of a DFA**
-------------------------

The **language L(M)** accepted by DFA M is:

.. math::
   
   L(M) = \{w \in \Sigma^* \mid \hat{\delta}(q_0, w) \in F\}

Where **Î´Ì‚** is the extended transition function.

**1.3 Nondeterministic Finite Automaton (NFA)**
-----------------------------------------------

An **NFA** is a 5-tuple: **N = (Q, Î£, Î´, qâ‚€, F)**

Key difference: **Î´: Q Ã— Î£ â†’ 2^Q** (transitions to subsets of states)

----

**2. Construction Examples**
============================

**Example 1: DFA for Binary Strings Ending in "01"**
----------------------------------------------------

**Problem:** Design a DFA that accepts all binary strings ending with "01".

**Solution Strategy:**
1. Track the last two characters seen
2. Use states to remember: nothing, last was 0, last was 1, last two were 01

**Formal Definition:**

* **States:** Q = {qâ‚€, qâ‚, qâ‚‚}
* **Alphabet:** Î£ = {0, 1}
* **Start state:** qâ‚€
* **Accept states:** F = {qâ‚‚}

**State meanings:**
* qâ‚€: initial state / last char was 1
* qâ‚: last character was 0  
* qâ‚‚: last two characters were 01 (ACCEPT)

**Transition Function Î´:**

.. math::
   
   \begin{array}{c|cc}
   \delta & 0 & 1 \\
   \hline
   \rightarrow q_0 & q_1 & q_0 \\
   q_1 & q_1 & q_2 \\
   q_2^* & q_1 & q_0
   \end{array}

**State Diagram:**

.. raw:: latex

   \begin{center}
   \begin{tikzpicture}[shorten >=1pt, node distance=2.5cm, auto]
   \tikzstyle{every state}=[fill=lightblue!20,draw=blue,text=black,minimum size=1cm]
   
   \node[state, initial] (q0) {$q_0$};
   \node[state, right of=q0] (q1) {$q_1$};
   \node[state, accepting, right of=q1] (q2) {$q_2$};
   
   \path[->] 
   (q0) edge[loop above] node {1} (q0)
        edge node {0} (q1)
   (q1) edge[loop above] node {0} (q1)
        edge node {1} (q2)
   (q2) edge[bend left=45] node {0} (q1)
        edge[bend right=60] node {1} (q0);
   \end{tikzpicture}
   \end{center}

**Example Execution:**
Input string "1001" â†’ qâ‚€ â†’Â¹ qâ‚€ â†’â° qâ‚ â†’â° qâ‚ â†’Â¹ qâ‚‚ âœ“ **ACCEPT**

**Example 2: NFA with Îµ-transitions**
------------------------------------

**Problem:** Build an NFA that accepts strings containing "ab" or "ba" as substrings.

**Solution Strategy:**
* Use parallel computation paths
* Path 1: Looking for "ab" 
* Path 2: Looking for "ba"
* Îµ-transitions for nondeterministic branching

**Formal Definition:**

* **States:** Q = {qâ‚€, qâ‚, qâ‚‚, qâ‚ƒ, qâ‚„, qâ‚…}
* **Alphabet:** Î£ = {a, b}
* **Start state:** qâ‚€
* **Accept states:** F = {qâ‚…}

**State Diagram:**

.. raw:: latex

   \begin{center}
   \begin{tikzpicture}[shorten >=1pt, node distance=2cm, auto]
   \tikzstyle{every state}=[fill=lightgreen!20,draw=darkgreen,text=black,minimum size=0.8cm]
   
   \node[state, initial] (q0) {$q_0$};
   \node[state, above right of=q0] (q1) {$q_1$};
   \node[state, right of=q1] (q2) {$q_2$};
   \node[state, below right of=q0] (q3) {$q_3$};
   \node[state, right of=q3] (q4) {$q_4$};
   \node[state, accepting, right of=q2, yshift=-1cm] (q5) {$q_5$};
   
   \path[->]
   (q0) edge[loop left] node {a,b} (q0)
        edge node {$\varepsilon$} (q1)
        edge node {$\varepsilon$} (q3)
   (q1) edge node {a} (q2)
   (q2) edge node {b} (q5)
   (q3) edge node {b} (q4)
   (q4) edge node {a} (q5)
   (q5) edge[loop right] node {a,b} (q5);
   \end{tikzpicture}
   \end{center}

**Path Analysis:**
* **For "ab":** qâ‚€ â†’áµ‹ qâ‚ â†’áµƒ qâ‚‚ â†’áµ‡ qâ‚…
* **For "ba":** qâ‚€ â†’áµ‹ qâ‚ƒ â†’áµ‡ qâ‚„ â†’áµƒ qâ‚…
* **Self-loop on qâ‚€:** Process other characters
* **Self-loop on qâ‚…:** Accept any suffix after finding pattern

----

**3. Practice Exercises**
=========================

**Exercise 1: DFA Construction**
-------------------------------

Design a DFA that accepts all strings over {0,1} with an even number of 0s and an odd number of 1s.

.. hint::
   
   **ğŸ’¡ Hint:** 
   
   * You need to track two properties simultaneously
   * Use 4 states: (even 0s, even 1s), (even 0s, odd 1s), etc.
   * Think about which state should be the accept state

.. admonition:: Solution
   :class: dropdown

   **Strategy:** Track parity of both 0s and 1s using state combinations.

   **Formal Definition:**
   * **States:** Q = {qâ‚€â‚€, qâ‚€â‚, qâ‚â‚€, qâ‚â‚} where qáµ¢â±¼ means: i = parity of 0s, j = parity of 1s (0 = even, 1 = odd)
   * **Start state:** qâ‚€â‚€ (even 0s, even 1s)
   * **Accept state:** F = {qâ‚€â‚} (even 0s, odd 1s)

   **Transition Table:**
   
   .. math::
      
      \begin{array}{c|cc}
      \delta & 0 & 1 \\
      \hline
      \rightarrow q_{00} & q_{10} & q_{01} \\
      q_{01}^* & q_{11} & q_{00} \\
      q_{10} & q_{00} & q_{11} \\
      q_{11} & q_{01} & q_{10}
      \end{array}

   **State Diagram:**

   .. raw:: latex

      \begin{center}
      \begin{tikzpicture}[shorten >=1pt, node distance=3cm, auto]
      \tikzstyle{every state}=[fill=lightyellow!20,draw=orange,text=black,minimum size=1cm]
      
      \node[state, initial] (q00) {$q_{00}$};
      \node[state, accepting, right of=q00] (q01) {$q_{01}$};
      \node[state, below of=q00] (q10) {$q_{10}$};
      \node[state, below of=q01] (q11) {$q_{11}$};
      
      \path[->]
      (q00) edge[bend left] node {1} (q01)
            edge[bend right] node {0} (q10)
      (q01) edge[bend left] node {1} (q00)
            edge[bend left] node {0} (q11)
      (q10) edge[bend right] node {0} (q00)
            edge[bend right] node {1} (q11)
      (q11) edge[bend left] node {0} (q01)
            edge[bend right] node {1} (q10);
      \end{tikzpicture}
      \end{center}

   **Example:** String "110" â†’ qâ‚€â‚€ â†’Â¹ qâ‚€â‚ â†’Â¹ qâ‚€â‚€ â†’â° qâ‚â‚€ âœ— **REJECT** (final state not accepting)

**Exercise 2: NFA to DFA Conversion**
------------------------------------

Convert the following NFA to an equivalent DFA using subset construction:

**Given NFA:** N = ({qâ‚€, qâ‚, qâ‚‚}, {a, b}, Î´, qâ‚€, {qâ‚‚})

**NFA Transition Function:**

.. math::
   
   \begin{array}{c|cc}
   \delta_{NFA} & a & b \\
   \hline
   \rightarrow q_0 & \{q_0, q_1\} & \{q_0\} \\
   q_1 & \emptyset & \{q_2\} \\
   q_2^* & \emptyset & \emptyset
   \end{array}

.. hint::
   
   **ğŸ’¡ Hint:** 
   
   * Start with {qâ‚€}
   * For each subset, compute transitions on each input symbol
   * A subset is accepting if it contains any accepting state from the NFA
   * Continue until no new subsets are generated

.. admonition:: Solution  
   :class: dropdown

   **Step-by-step Subset Construction:**

   **Step 1:** Start with {qâ‚€}
   
   **Step 2:** Compute transitions from {qâ‚€}:
   * on 'a': Î´(qâ‚€, a) = {qâ‚€, qâ‚}
   * on 'b': Î´(qâ‚€, b) = {qâ‚€}
   
   **Step 3:** Compute transitions from {qâ‚€, qâ‚}:
   * on 'a': Î´(qâ‚€, a) âˆª Î´(qâ‚, a) = {qâ‚€, qâ‚} âˆª âˆ… = {qâ‚€, qâ‚}
   * on 'b': Î´(qâ‚€, b) âˆª Î´(qâ‚, b) = {qâ‚€} âˆª {qâ‚‚} = {qâ‚€, qâ‚‚}
   
   **Step 4:** Compute transitions from {qâ‚€, qâ‚‚}:
   * on 'a': Î´(qâ‚€, a) âˆª Î´(qâ‚‚, a) = {qâ‚€, qâ‚} âˆª âˆ… = {qâ‚€, qâ‚}
   * on 'b': Î´(qâ‚€, b) âˆª Î´(qâ‚‚, b) = {qâ‚€} âˆª âˆ… = {qâ‚€}

   **Final DFA:**
   * **States:** {A, B, C} where A={qâ‚€}, B={qâ‚€,qâ‚}, C={qâ‚€,qâ‚‚}
   * **Start:** A
   * **Accept:** {C} (contains qâ‚‚)

   **DFA Transition Table:**
   
   .. math::
      
      \begin{array}{c|cc}
      \delta_{DFA} & a & b \\
      \hline
      \rightarrow A & B & A \\
      B & B & C \\
      C^* & B & A
      \end{array}

   **DFA State Diagram:**

   .. raw:: latex

      \begin{center}
      \begin{tikzpicture}[shorten >=1pt, node distance=2.5cm, auto]
      \tikzstyle{every state}=[fill=lightcyan!20,draw=teal,text=black,minimum size=1cm]
      
      \node[state, initial] (A) {$A$};
      \node[state, right of=A] (B) {$B$};
      \node[state, accepting, right of=B] (C) {$C$};
      
      \path[->]
      (A) edge[loop above] node {b} (A)
          edge node {a} (B)
      (B) edge[loop above] node {a} (B)
          edge node {b} (C)
      (C) edge[bend left=45] node {a} (B)
          edge[bend right=60] node {b} (A);
      \end{tikzpicture}
      \end{center}

**Exercise 3: Language Design**
------------------------------

Design a DFA that accepts the language L = {w âˆˆ {a,b}* | w has substring "aba"}.

.. hint::
   
   **ğŸ’¡ Hint:** 
   
   * Track progress toward finding "aba"
   * States should represent: seen nothing useful, seen "a", seen "ab", seen "aba"
   * Once you've seen "aba", you accept regardless of what follows

.. admonition:: Solution
   :class: dropdown

   **Strategy:** Track the longest prefix of "aba" that matches a suffix of the input read so far.
   
   **Formal Definition:**
   * **States:** {qâ‚€, qâ‚, qâ‚‚, qâ‚ƒ}
   * **qâ‚€:** no useful progress toward "aba"
   * **qâ‚:** last character was 'a' (potential start of "aba")  
   * **qâ‚‚:** last two characters were "ab"
   * **qâ‚ƒ:** found "aba" - accept state
   * **Start:** qâ‚€
   * **Accept:** F = {qâ‚ƒ}

   **Transition Table:**
   
   .. math::
      
      \begin{array}{c|cc}
      \delta & a & b \\
      \hline
      \rightarrow q_0 & q_1 & q_0 \\
      q_1 & q_1 & q_2 \\
      q_2 & q_3 & q_0 \\
      q_3^* & q_1 & q_0
      \end{array}

   **State Diagram:**

   .. raw:: latex

      \begin{center}
      \begin{tikzpicture}[shorten >=1pt, node distance=2.5cm, auto]
      \tikzstyle{every state}=[fill=lightpink!20,draw=purple,text=black,minimum size=1cm]
      
      \node[state, initial] (q0) {$q_0$};
      \node[state, right of=q0] (q1) {$q_1$};
      \node[state, right of=q1] (q2) {$q_2$};
      \node[state, accepting, right of=q2] (q3) {$q_3$};
      
      \path[->]
      (q0) edge[loop above] node {b} (q0)
           edge node {a} (q1)
      (q1) edge[loop above] node {a} (q1)
           edge node {b} (q2)
      (q2) edge node {a} (q3)
           edge[bend left=60] node {b} (q0)
      (q3) edge[bend left] node {a} (q1)
           edge[bend left=80] node {b} (q0);
      \end{tikzpicture}
      \end{center}

   **Example Trace for "aababa":**
   qâ‚€ â†’áµƒ qâ‚ â†’áµƒ qâ‚ â†’áµ‡ qâ‚‚ â†’áµƒ qâ‚ƒ â†’áµ‡ qâ‚€ â†’áµƒ qâ‚
   
   **Result:** String accepted because we passed through qâ‚ƒ (accepting state).

----

**4. Video Resources**
======================

.. raw:: html

   <div style="margin: 20px 0;">
   <h3>ğŸ“º Finite Automata Fundamentals</h3>
   <video controls autoplay muted width="100%" style="max-width: 800px;">
     <source src="_static/videos/finite_automata_intro.mp4" type="video/mp4">
     <p>Your browser does not support the video tag.</p>
   </video>
   <p><em>Video: Introduction to DFAs and NFAs - Definitions and Basic Construction (25 minutes)</em></p>
   </div>

.. raw:: html

   <div style="margin: 20px 0;">
   <h3>ğŸ¥ Subset Construction Algorithm</h3>
   <video controls width="100%" style="max-width: 800px;">
     <source src="_static/videos/nfa_to_dfa_conversion.mp4" type="video/mp4">
     <p>Your browser does not support the video tag.</p>
   </video>
   <p><em>Video: Step-by-step NFA to DFA conversion with worked examples (20 minutes)</em></p>
   </div>

----

**5. Summary & Key Takeaways**
==============================

.. admonition:: ğŸ“ Chapter Summary
   :class: tip

   **Core Concepts Mastered:**
   
   * âœ… **DFA Definition** - 5-tuple components and their roles
   * âœ… **NFA Definition** - Nondeterminism and Îµ-transitions  
   * âœ… **Language Acceptance** - Formal definition using extended Î´
   * âœ… **Construction Techniques** - Systematic automata design
   * âœ… **Equivalence** - NFA to DFA conversion algorithms
   
   **Problem-Solving Skills:**
   
   * ğŸ”§ Designing automata for specific language requirements
   * ğŸ”§ Tracking multiple properties with state combinations
   * ğŸ”§ Converting between deterministic and nondeterministic models
   * ğŸ”§ Proving correctness of automata constructions

**Important Theorems:**

.. admonition:: ğŸ“š Key Results
   :class: note

   * **Theorem 2.1:** Every NFA has an equivalent DFA
   * **Theorem 2.2:** The regular languages are closed under union, concatenation, and Kleene star
   * **Theorem 2.3:** A language is regular if and only if it is accepted by some finite automaton

----

**Next Steps**
==============

.. note::
   
   **ğŸš€ Ready for Regular Expressions?**
   
   In Chapter 3, we'll explore:
   * Regular expression syntax and semantics
   * Equivalence between regular expressions and finite automata
   * Converting between representations
   * Pumping lemma for regular languages
   
   :doc:`Continue to Regular Expressions â†’ <regular_expressions>`

.. admonition:: Self-Check
   :class: important

   **Before proceeding, ensure you can:**
   
   * [ ] Draw DFAs and NFAs for given language descriptions
   * [ ] Execute automata on input strings step-by-step
   * [ ] Convert NFAs to equivalent DFAs systematically  
   * [ ] Prove that an automaton accepts a specific language
   
   **Need more practice?** Try the additional exercises in :doc:`solutions_manual`

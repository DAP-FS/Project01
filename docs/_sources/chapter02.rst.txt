===============================
Chapter 2: Finite Automata
===============================

.. rubric:: üéØ Learning Objectives

By the end of this chapter, you will be able to:

* Define and construct Deterministic Finite Automata (DFA)
* Build Nondeterministic Finite Automata (NFA) 
* Convert NFAs to DFAs using subset construction
* Design automata for specific language requirements
* Prove language acceptance using formal methods

----

**üìã Prerequisites**
====================

.. note::
   
   **Essential:** Basic set theory, function definitions
   
   **Helpful:** Graph theory basics, state-based thinking

----

**1. Theory & Formal Definitions**
==================================

**1.1 Deterministic Finite Automaton (DFA)**
---------------------------------------------

A **DFA** is a 5-tuple: **M = (Q, Œ£, Œ¥, q‚ÇÄ, F)**

Where:

* **Q** = finite set of states
* **Œ£** = finite input alphabet  
* **Œ¥: Q √ó Œ£ ‚Üí Q** = transition function
* **q‚ÇÄ ‚àà Q** = start state
* **F ‚äÜ Q** = set of accept (final) states

**1.2 Language of a DFA**
-------------------------

The **language L(M)** accepted by DFA M is:

.. math::
   
   L(M) = \{w \in \Sigma^* \mid \hat{\delta}(q_0, w) \in F\}

Where **Œ¥ÃÇ** is the extended transition function.

**1.3 Nondeterministic Finite Automaton (NFA)**
-----------------------------------------------

An **NFA** is a 5-tuple: **N = (Q, Œ£, Œ¥, q‚ÇÄ, F)**

Key difference: **Œ¥: Q √ó Œ£ ‚Üí 2^Q** (transitions to subsets of states)

----

**2. Construction Examples**
============================

**Example 1: DFA for Binary Strings Ending in "01"**
----------------------------------------------------

**Problem:** Design a DFA that accepts all binary strings ending with "01".

**Solution Strategy:**
1. Track the last two characters seen
2. Use states to remember: nothing, last was 0, last was 1, last two were 01

**Formal Definition:**

* **States:** Q = {q‚ÇÄ, q‚ÇÅ, q‚ÇÇ}
* **Alphabet:** Œ£ = {0, 1}
* **Start state:** q‚ÇÄ
* **Accept states:** F = {q‚ÇÇ}

**State meanings:**
* q‚ÇÄ: initial state / last char was 1
* q‚ÇÅ: last character was 0  
* q‚ÇÇ: last two characters were 01 (ACCEPT)

**Transition Function Œ¥:**

.. math::
   
   \begin{array}{c|cc}
   \delta & 0 & 1 \\
   \hline
   \rightarrow q_0 & q_1 & q_0 \\
   q_1 & q_1 & q_2 \\
   q_2^* & q_1 & q_0
   \end{array}

**State Diagram:**

.. raw:: latex

   \begin{center}
   \begin{tikzpicture}[shorten >=1pt, node distance=2.5cm, auto]
   \tikzstyle{every state}=[fill=lightblue!20,draw=blue,text=black,minimum size=1cm]
   
   \node[state, initial] (q0) {$q_0$};
   \node[state, right of=q0] (q1) {$q_1$};
   \node[state, accepting, right of=q1] (q2) {$q_2$};
   
   \path[->] 
   (q0) edge[loop above] node {1} (q0)
        edge node {0} (q1)
   (q1) edge[loop above] node {0} (q1)
        edge node {1} (q2)
   (q2) edge[bend left=45] node {0} (q1)
        edge[bend right=60] node {1} (q0);
   \end{tikzpicture}
   \end{center}

**Example Execution:**
Input string "1001" ‚Üí q‚ÇÄ ‚Üí¬π q‚ÇÄ ‚Üí‚Å∞ q‚ÇÅ ‚Üí‚Å∞ q‚ÇÅ ‚Üí¬π q‚ÇÇ ‚úì **ACCEPT**

**Example 2: NFA with Œµ-transitions**
------------------------------------

**Problem:** Build an NFA that accepts strings containing "ab" or "ba" as substrings.

**Solution Strategy:**
* Use parallel computation paths
* Path 1: Looking for "ab" 
* Path 2: Looking for "ba"
* Œµ-transitions for nondeterministic branching

**Formal Definition:**

* **States:** Q = {q‚ÇÄ, q‚ÇÅ, q‚ÇÇ, q‚ÇÉ, q‚ÇÑ, q‚ÇÖ}
* **Alphabet:** Œ£ = {a, b}
* **Start state:** q‚ÇÄ
* **Accept states:** F = {q‚ÇÖ}

**State Diagram:**

.. raw:: latex

   \begin{center}
   \begin{tikzpicture}[shorten >=1pt, node distance=2cm, auto]
   \tikzstyle{every state}=[fill=lightgreen!20,draw=darkgreen,text=black,minimum size=0.8cm]
   
   \node[state, initial] (q0) {$q_0$};
   \node[state, above right of=q0] (q1) {$q_1$};
   \node[state, right of=q1] (q2) {$q_2$};
   \node[state, below right of=q0] (q3) {$q_3$};
   \node[state, right of=q3] (q4) {$q_4$};
   \node[state, accepting, right of=q2, yshift=-1cm] (q5) {$q_5$};
   
   \path[->]
   (q0) edge[loop left] node {a,b} (q0)
        edge node {$\varepsilon$} (q1)
        edge node {$\varepsilon$} (q3)
   (q1) edge node {a} (q2)
   (q2) edge node {b} (q5)
   (q3) edge node {b} (q4)
   (q4) edge node {a} (q5)
   (q5) edge[loop right] node {a,b} (q5);
   \end{tikzpicture}
   \end{center}

**Path Analysis:**
* **For "ab":** q‚ÇÄ ‚Üí·µã q‚ÇÅ ‚Üí·µÉ q‚ÇÇ ‚Üí·µá q‚ÇÖ
* **For "ba":** q‚ÇÄ ‚Üí·µã q‚ÇÉ ‚Üí·µá q‚ÇÑ ‚Üí·µÉ q‚ÇÖ
* **Self-loop on q‚ÇÄ:** Process other characters
* **Self-loop on q‚ÇÖ:** Accept any suffix after finding pattern

----

**3. Practice Exercises**
=========================

**Exercise 1: DFA Construction**
-------------------------------

Design a DFA that accepts all strings over {0,1} with an even number of 0s and an odd number of 1s.

.. hint::
   
   **üí° Hint:** 
   
   * You need to track two properties simultaneously
   * Use 4 states: (even 0s, even 1s), (even 0s, odd 1s), etc.
   * Think about which state should be the accept state

.. admonition:: Solution
   :class: dropdown

   **Strategy:** Track parity of both 0s and 1s using state combinations.

   **Formal Definition:**
   * **States:** Q = {q‚ÇÄ‚ÇÄ, q‚ÇÄ‚ÇÅ, q‚ÇÅ‚ÇÄ, q‚ÇÅ‚ÇÅ} where q·µ¢‚±º means: i = parity of 0s, j = parity of 1s (0 = even, 1 = odd)
   * **Start state:** q‚ÇÄ‚ÇÄ (even 0s, even 1s)
   * **Accept state:** F = {q‚ÇÄ‚ÇÅ} (even 0s, odd 1s)

   **Transition Table:**
   
   .. math::
      
      \begin{array}{c|cc}
      \delta & 0 & 1 \\
      \hline
      \rightarrow q_{00} & q_{10} & q_{01} \\
      q_{01}^* & q_{11} & q_{00} \\
      q_{10} & q_{00} & q_{11} \\
      q_{11} & q_{01} & q_{10}
      \end{array}

   **State Diagram:**

   .. raw:: latex

      \begin{center}
      \begin{tikzpicture}[shorten >=1pt, node distance=3cm, auto]
      \tikzstyle{every state}=[fill=lightyellow!20,draw=orange,text=black,minimum size=1cm]
      
      \node[state, initial] (q00) {$q_{00}$};
      \node[state, accepting, right of=q00] (q01) {$q_{01}$};
      \node[state, below of=q00] (q10) {$q_{10}$};
      \node[state, below of=q01] (q11) {$q_{11}$};
      
      \path[->]
      (q00) edge[bend left] node {1} (q01)
            edge[bend right] node {0} (q10)
      (q01) edge[bend left] node {1} (q00)
            edge[bend left] node {0} (q11)
      (q10) edge[bend right] node {0} (q00)
            edge[bend right] node {1} (q11)
      (q11) edge[bend left] node {0} (q01)
            edge[bend right] node {1} (q10);
      \end{tikzpicture}
      \end{center}

   **Example:** String "110" ‚Üí q‚ÇÄ‚ÇÄ ‚Üí¬π q‚ÇÄ‚ÇÅ ‚Üí¬π q‚ÇÄ‚ÇÄ ‚Üí‚Å∞ q‚ÇÅ‚ÇÄ ‚úó **REJECT** (final state not accepting)

**Exercise 2: NFA to DFA Conversion**
------------------------------------

Convert the following NFA to an equivalent DFA using subset construction:

**Given NFA:** N = ({q‚ÇÄ, q‚ÇÅ, q‚ÇÇ}, {a, b}, Œ¥, q‚ÇÄ, {q‚ÇÇ})

**NFA Transition Function:**

.. math::
   
   \begin{array}{c|cc}
   \delta_{NFA} & a & b \\
   \hline
   \rightarrow q_0 & \{q_0, q_1\} & \{q_0\} \\
   q_1 & \emptyset & \{q_2\} \\
   q_2^* & \emptyset & \emptyset
   \end{array}

.. hint::
   
   **üí° Hint:** 
   
   * Start with {q‚ÇÄ}
   * For each subset, compute transitions on each input symbol
   * A subset is accepting if it contains any accepting state from the NFA
   * Continue until no new subsets are generated

.. admonition:: Solution  
   :class: dropdown

   **Step-by-step Subset Construction:**

   **Step 1:** Start with {q‚ÇÄ}
   
   **Step 2:** Compute transitions from {q‚ÇÄ}:
   * on 'a': Œ¥(q‚ÇÄ, a) = {q‚ÇÄ, q‚ÇÅ}
   * on 'b': Œ¥(q‚ÇÄ, b) = {q‚ÇÄ}
   
   **Step 3:** Compute transitions from {q‚ÇÄ, q‚ÇÅ}:
   * on 'a': Œ¥(q‚ÇÄ, a) ‚à™ Œ¥(q‚ÇÅ, a) = {q‚ÇÄ, q‚ÇÅ} ‚à™ ‚àÖ = {q‚ÇÄ, q‚ÇÅ}
   * on 'b': Œ¥(q‚ÇÄ, b) ‚à™ Œ¥(q‚ÇÅ, b) = {q‚ÇÄ} ‚à™ {q‚ÇÇ} = {q‚ÇÄ, q‚ÇÇ}
   
   **Step 4:** Compute transitions from {q‚ÇÄ, q‚ÇÇ}:
   * on 'a': Œ¥(q‚ÇÄ, a) ‚à™ Œ¥(q‚ÇÇ, a) = {q‚ÇÄ, q‚ÇÅ} ‚à™ ‚àÖ = {q‚ÇÄ, q‚ÇÅ}
   * on 'b': Œ¥(q‚ÇÄ, b) ‚à™ Œ¥(q‚ÇÇ, b) = {q‚ÇÄ} ‚à™ ‚àÖ = {q‚ÇÄ}

   **Final DFA:**
   * **States:** {A, B, C} where A={q‚ÇÄ}, B={q‚ÇÄ,q‚ÇÅ}, C={q‚ÇÄ,q‚ÇÇ}
   * **Start:** A
   * **Accept:** {C} (contains q‚ÇÇ)

   **DFA Transition Table:**
   
   .. math::
      
      \begin{array}{c|cc}
      \delta_{DFA} & a & b \\
      \hline
      \rightarrow A & B & A \\
      B & B & C \\
      C^* & B & A
      \end{array}

   **DFA State Diagram:**

   .. raw:: latex

      \begin{center}
      \begin{tikzpicture}[shorten >=1pt, node distance=2.5cm, auto]
      \tikzstyle{every state}=[fill=lightcyan!20,draw=teal,text=black,minimum size=1cm]
      
      \node[state, initial] (A) {$A$};
      \node[state, right of=A] (B) {$B$};
      \node[state, accepting, right of=B] (C) {$C$};
      
      \path[->]
      (A) edge[loop above] node {b} (A)
          edge node {a} (B)
      (B) edge[loop above] node {a} (B)
          edge node {b} (C)
      (C) edge[bend left=45] node {a} (B)
          edge[bend right=60] node {b} (A);
      \end{tikzpicture}
      \end{center}

**Exercise 3: Language Design**
------------------------------

Design a DFA that accepts the language L = {w ‚àà {a,b}* | w has substring "aba"}.

.. hint::
   
   **üí° Hint:** 
   
   * Track progress toward finding "aba"
   * States should represent: seen nothing useful, seen "a", seen "ab", seen "aba"
   * Once you've seen "aba", you accept regardless of what follows

.. admonition:: Solution
   :class: dropdown

   **Strategy:** Track the longest prefix of "aba" that matches a suffix of the input read so far.
   
   **Formal Definition:**
   * **States:** {q‚ÇÄ, q‚ÇÅ, q‚ÇÇ, q‚ÇÉ}
   * **q‚ÇÄ:** no useful progress toward "aba"
   * **q‚ÇÅ:** last character was 'a' (potential start of "aba")  
   * **q‚ÇÇ:** last two characters were "ab"
   * **q‚ÇÉ:** found "aba" - accept state
   * **Start:** q‚ÇÄ
   * **Accept:** F = {q‚ÇÉ}

   **Transition Table:**
   
   .. math::
      
      \begin{array}{c|cc}
      \delta & a & b \\
      \hline
      \rightarrow q_0 & q_1 & q_0 \\
      q_1 & q_1 & q_2 \\
      q_2 & q_3 & q_0 \\
      q_3^* & q_1 & q_0
      \end{array}

   **State Diagram:**

   .. raw:: latex

      \begin{center}
      \begin{tikzpicture}[shorten >=1pt, node distance=2.5cm, auto]
      \tikzstyle{every state}=[fill=lightpink!20,draw=purple,text=black,minimum size=1cm]
      
      \node[state, initial] (q0) {$q_0$};
      \node[state, right of=q0] (q1) {$q_1$};
      \node[state, right of=q1] (q2) {$q_2$};
      \node[state, accepting, right of=q2] (q3) {$q_3$};
      
      \path[->]
      (q0) edge[loop above] node {b} (q0)
           edge node {a} (q1)
      (q1) edge[loop above] node {a} (q1)
           edge node {b} (q2)
      (q2) edge node {a} (q3)
           edge[bend left=60] node {b} (q0)
      (q3) edge[bend left] node {a} (q1)
           edge[bend left=80] node {b} (q0);
      \end{tikzpicture}
      \end{center}

   **Example Trace for "aababa":**
   q‚ÇÄ ‚Üí·µÉ q‚ÇÅ ‚Üí·µÉ q‚ÇÅ ‚Üí·µá q‚ÇÇ ‚Üí·µÉ q‚ÇÉ ‚Üí·µá q‚ÇÄ ‚Üí·µÉ q‚ÇÅ
   
   **Result:** String accepted because we passed through q‚ÇÉ (accepting state).

----

**4. Video Resources**
======================

.. raw:: html

   <div style="margin: 20px 0;">
   <h3>üì∫ Finite Automata Fundamentals</h3>
   <video controls autoplay muted width="100%" style="max-width: 800px;">
     <source src="_static/videos/finite_automata_intro.mp4" type="video/mp4">
     <p>Your browser does not support the video tag.</p>
   </video>
   <p><em>Video: Introduction to DFAs and NFAs - Definitions and Basic Construction (25 minutes)</em></p>
   </div>

.. raw:: html

   <div style="margin: 20px 0;">
   <h3>üé• Subset Construction Algorithm</h3>
   <video controls width="100%" style="max-width: 800px;">
     <source src="_static/videos/nfa_to_dfa_conversion.mp4" type="video/mp4">
     <p>Your browser does not support the video tag.</p>
   </video>
   <p><em>Video: Step-by-step NFA to DFA conversion with worked examples (20 minutes)</em></p>
   </div>

----

**5. Summary & Key Takeaways**
==============================

.. admonition:: üéì Chapter Summary
   :class: tip

   **Core Concepts Mastered:**
   
   * ‚úÖ **DFA Definition** - 5-tuple components and their roles
   * ‚úÖ **NFA Definition** - Nondeterminism and Œµ-transitions  
   * ‚úÖ **Language Acceptance** - Formal definition using extended Œ¥
   * ‚úÖ **Construction Techniques** - Systematic automata design
   * ‚úÖ **Equivalence** - NFA to DFA conversion algorithms
   
   **Problem-Solving Skills:**
   
   * üîß Designing automata for specific language requirements
   * üîß Tracking multiple properties with state combinations
   * üîß Converting between deterministic and nondeterministic models
   * üîß Proving correctness of automata constructions

**Important Theorems:**

.. admonition:: üìö Key Results
   :class: note

   * **Theorem 2.1:** Every NFA has an equivalent DFA
   * **Theorem 2.2:** The regular languages are closed under union, concatenation, and Kleene star
   * **Theorem 2.3:** A language is regular if and only if it is accepted by some finite automaton

----

**Next Steps**
==============

.. note::
   
   **üöÄ Ready for Regular Expressions?**
   
   In Chapter 3, we'll explore:
   * Regular expression syntax and semantics
   * Equivalence between regular expressions and finite automata
   * Converting between representations
   * Pumping lemma for regular languages
   
   :doc:`Continue to Regular Expressions ‚Üí <regular_expressions>`

.. admonition:: Self-Check
   :class: important

   **Before proceeding, ensure you can:**
   
   * [ ] Draw DFAs and NFAs for given language descriptions
   * [ ] Execute automata on input strings step-by-step
   * [ ] Convert NFAs to equivalent DFAs systematically  
   * [ ] Prove that an automaton accepts a specific language
   
   **Need more practice?** Try the additional exercises in :doc:`solutions_manual`

===============================
Chapter 2: Finite Automata
===============================

.. rubric:: ğŸ¯ Learning Objectives

By the end of this chapter, you will be able to:

* Define and construct Deterministic Finite Automata (DFA)
* Build Nondeterministic Finite Automata (NFA) 
* Convert NFAs to DFAs using subset construction
* Design automata for specific language requirements
* Prove language acceptance using formal methods

----

**ğŸ“‹ Prerequisites**
====================

.. note::
   
   **Essential:** Basic set theory, function definitions
   
   **Helpful:** Graph theory basics, state-based thinking

----

**1. Theory & Formal Definitions**
==================================

**1.1 Deterministic Finite Automaton (DFA)**
---------------------------------------------

A **DFA** is a 5-tuple: **M = (Q, Î£, Î´, qâ‚€, F)**

Where:

* **Q** = finite set of states
* **Î£** = finite input alphabet  
* **Î´: Q Ã— Î£ â†’ Q** = transition function
* **qâ‚€ âˆˆ Q** = start state
* **F âŠ† Q** = set of accept (final) states

**1.2 Language of a DFA**
-------------------------

The **language L(M)** accepted by DFA M is:

.. math::
   
   L(M) = \{w \in \Sigma^* \mid \hat{\delta}(q_0, w) \in F\}

Where **Î´Ì‚** is the extended transition function.

**1.3 Nondeterministic Finite Automaton (NFA)**
-----------------------------------------------

An **NFA** is a 5-tuple: **N = (Q, Î£, Î´, qâ‚€, F)**

Key difference: **Î´: Q Ã— Î£ â†’ 2^Q** (transitions to subsets of states)

----

**2. Construction Examples**
============================

**Example 1: DFA for Binary Strings Ending in "01"**
----------------------------------------------------

**Problem:** Design a DFA that accepts all binary strings ending with "01".

**Solution Strategy:**
1. Track the last two characters seen
2. Use states to remember: nothing, last was 0, last was 1, last two were 01

.. code-block:: text

   States: Q = {qâ‚€, qâ‚, qâ‚‚, qâ‚ƒ}
   Alphabet: Î£ = {0, 1}
   Start state: qâ‚€
   Accept states: F = {qâ‚‚}
   
   State meanings:
   qâ‚€: initial state / last char was 1
   qâ‚: last character was 0  
   qâ‚‚: last two characters were 01 (ACCEPT)
   qâ‚ƒ: dead state (not used in this example)

**Transition Function Î´:**

.. code-block:: text

   Î´(qâ‚€, 0) = qâ‚
   Î´(qâ‚€, 1) = qâ‚€
   Î´(qâ‚, 0) = qâ‚  
   Î´(qâ‚, 1) = qâ‚‚
   Î´(qâ‚‚, 0) = qâ‚
   Î´(qâ‚‚, 1) = qâ‚€

**State Diagram:**

.. code-block:: text

          0        1
   â†’qâ‚€ -----â†’ qâ‚ -----â†’ ((qâ‚‚))
    â†‘  â†–1      â†‘0       â†™0
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

**Example 2: NFA with Îµ-transitions**
------------------------------------

**Problem:** Build an NFA that accepts strings containing "ab" or "ba" as substrings.

.. code-block:: text

   This requires parallel computation paths:
   Path 1: Looking for "ab"
   Path 2: Looking for "ba"
   
   States: {qâ‚€, qâ‚, qâ‚‚, qâ‚ƒ, qâ‚„, qâ‚…}
   
   qâ‚€: start state
   qâ‚, qâ‚‚: tracking "ab" pattern  
   qâ‚ƒ, qâ‚„: tracking "ba" pattern
   qâ‚…: accept state (found either pattern)

----

**3. Practice Exercises**
=========================

**Exercise 1: DFA Construction**
-------------------------------

Design a DFA that accepts all strings over {0,1} with an even number of 0s and an odd number of 1s.

.. hint::
   
   **ğŸ’¡ Hint:** 
   
   * You need to track two properties simultaneously
   * Use 4 states: (even 0s, even 1s), (even 0s, odd 1s), etc.
   * Think about which state should be the accept state

.. admonition:: Solution
   :class: dropdown

   .. code-block:: text

      States: Q = {qâ‚€â‚€, qâ‚€â‚, qâ‚â‚€, qâ‚â‚}
      where qáµ¢â±¼ means: i = parity of 0s, j = parity of 1s
      (0 = even, 1 = odd)
      
      Start state: qâ‚€â‚€ (even 0s, even 1s)
      Accept state: F = {qâ‚€â‚} (even 0s, odd 1s)
      
      Transitions:
      Î´(qâ‚€â‚€, 0) = qâ‚â‚€    Î´(qâ‚€â‚€, 1) = qâ‚€â‚
      Î´(qâ‚€â‚, 0) = qâ‚â‚    Î´(qâ‚€â‚, 1) = qâ‚€â‚€  
      Î´(qâ‚â‚€, 0) = qâ‚€â‚€    Î´(qâ‚â‚€, 1) = qâ‚â‚
      Î´(qâ‚â‚, 0) = qâ‚€â‚    Î´(qâ‚â‚, 1) = qâ‚â‚€
      
      State Diagram:
               0           1
      â†’qâ‚€â‚€ âŸ· qâ‚â‚€     qâ‚€â‚€ âŸ· ((qâ‚€â‚))
         â†‘â†“ 1   â†‘â†“ 1      â†‘â†“ 0   â†‘â†“ 0  
       qâ‚€â‚ âŸ· qâ‚â‚     qâ‚â‚€ âŸ· qâ‚â‚
           0           1

**Exercise 2: NFA to DFA Conversion**
------------------------------------

Convert the following NFA to an equivalent DFA using subset construction:

.. code-block:: text

   NFA N = ({qâ‚€, qâ‚, qâ‚‚}, {a, b}, Î´, qâ‚€, {qâ‚‚})
   
   Î´(qâ‚€, a) = {qâ‚€, qâ‚}
   Î´(qâ‚€, b) = {qâ‚€}
   Î´(qâ‚, a) = âˆ…
   Î´(qâ‚, b) = {qâ‚‚}
   Î´(qâ‚‚, a) = âˆ…  
   Î´(qâ‚‚, b) = âˆ…

.. hint::
   
   **ğŸ’¡ Hint:** 
   
   * Start with {qâ‚€}
   * For each subset, compute transitions on each input symbol
   * A subset is accepting if it contains any accepting state from the NFA
   * Continue until no new subsets are generated

.. admonition:: Solution  
   :class: dropdown

   .. code-block:: text

      Step-by-step subset construction:
      
      Start: {qâ‚€}
      
      From {qâ‚€}:
      - on 'a': Î´(qâ‚€, a) = {qâ‚€, qâ‚}
      - on 'b': Î´(qâ‚€, b) = {qâ‚€}
      
      From {qâ‚€, qâ‚}:
      - on 'a': Î´(qâ‚€, a) âˆª Î´(qâ‚, a) = {qâ‚€, qâ‚} âˆª âˆ… = {qâ‚€, qâ‚}
      - on 'b': Î´(qâ‚€, b) âˆª Î´(qâ‚, b) = {qâ‚€} âˆª {qâ‚‚} = {qâ‚€, qâ‚‚}
      
      From {qâ‚€, qâ‚‚}:
      - on 'a': Î´(qâ‚€, a) âˆª Î´(qâ‚‚, a) = {qâ‚€, qâ‚} âˆª âˆ… = {qâ‚€, qâ‚}
      - on 'b': Î´(qâ‚€, b) âˆª Î´(qâ‚‚, b) = {qâ‚€} âˆª âˆ… = {qâ‚€}
      
      DFA states: {{qâ‚€}, {qâ‚€, qâ‚}, {qâ‚€, qâ‚‚}}
      Accept states: {{qâ‚€, qâ‚‚}} (contains qâ‚‚)
      
      Final DFA:
      States: {A, B, C} where A={qâ‚€}, B={qâ‚€,qâ‚}, C={qâ‚€,qâ‚‚}
      Start: A
      Accept: {C}
      
      Transitions:
      Î´(A, a) = B    Î´(A, b) = A
      Î´(B, a) = B    Î´(B, b) = C  
      Î´(C, a) = B    Î´(C, b) = A

**Exercise 3: Language Design**
------------------------------

Design a DFA that accepts the language L = {w âˆˆ {a,b}* | w has substring "aba"}.

.. hint::
   
   **ğŸ’¡ Hint:** 
   
   * Track progress toward finding "aba"
   * States should represent: seen nothing useful, seen "a", seen "ab", seen "aba"
   * Once you've seen "aba", you accept regardless of what follows

.. admonition:: Solution
   :class: dropdown

   .. code-block:: text

      Strategy: Track the longest prefix of "aba" that matches a suffix of the input read so far.
      
      States: {qâ‚€, qâ‚, qâ‚‚, qâ‚ƒ}
      qâ‚€: no useful progress toward "aba"
      qâ‚: last character was 'a' (potential start of "aba")  
      qâ‚‚: last two characters were "ab"
      qâ‚ƒ: found "aba" - accept state
      
      Start: qâ‚€
      Accept: F = {qâ‚ƒ}
      
      Transitions:
      Î´(qâ‚€, a) = qâ‚    Î´(qâ‚€, b) = qâ‚€
      Î´(qâ‚, a) = qâ‚    Î´(qâ‚, b) = qâ‚‚
      Î´(qâ‚‚, a) = qâ‚ƒ    Î´(qâ‚‚, b) = qâ‚€  
      Î´(qâ‚ƒ, a) = qâ‚    Î´(qâ‚ƒ, b) = qâ‚€
      
      Note: From qâ‚ƒ, we still need to track for more "aba" patterns
      
      Example trace for "aababa":
      qâ‚€ --a--> qâ‚ --a--> qâ‚ --b--> qâ‚‚ --a--> qâ‚ƒ --b--> qâ‚€ --a--> qâ‚
      Final state qâ‚ âˆ‰ F, but we passed through qâ‚ƒ, so... 
      
      Wait - let me reconsider. Once in qâ‚ƒ, we stay accepting:
      
      Better design:
      Î´(qâ‚ƒ, a) = qâ‚ƒ    Î´(qâ‚ƒ, b) = qâ‚ƒ
      
      Or track ongoing patterns while staying accepting.

----

**4. Video Resources**
======================

.. raw:: html

   <div style="margin: 20px 0;">
   <h3>ğŸ“º Finite Automata Fundamentals</h3>
   <video controls autoplay muted width="100%" style="max-width: 800px;">
     <source src="_static/videos/finite_automata_intro.mp4" type="video/mp4">
     <p>Your browser does not support the video tag.</p>
   </video>
   <p><em>Video: Introduction to DFAs and NFAs - Definitions and Basic Construction (25 minutes)</em></p>
   </div>

.. raw:: html

   <div style="margin: 20px 0;">
   <h3>ğŸ¥ Subset Construction Algorithm</h3>
   <video controls width="100%" style="max-width: 800px;">
     <source src="_static/videos/nfa_to_dfa_conversion.mp4" type="video/mp4">
     <p>Your browser does not support the video tag.</p>
   </video>
   <p><em>Video: Step-by-step NFA to DFA conversion with worked examples (20 minutes)</em></p>
   </div>

----

**5. Summary & Key Takeaways**
==============================

.. admonition:: ğŸ“ Chapter Summary
   :class: tip

   **Core Concepts Mastered:**
   
   * âœ… **DFA Definition** - 5-tuple components and their roles
   * âœ… **NFA Definition** - Nondeterminism and Îµ-transitions  
   * âœ… **Language Acceptance** - Formal definition using extended Î´
   * âœ… **Construction Techniques** - Systematic automata design
   * âœ… **Equivalence** - NFA to DFA conversion algorithms
   
   **Problem-Solving Skills:**
   
   * ğŸ”§ Designing automata for specific language requirements
   * ğŸ”§ Tracking multiple properties with state combinations
   * ğŸ”§ Converting between deterministic and nondeterministic models
   * ğŸ”§ Proving correctness of automata constructions

**Important Theorems:**

.. admonition:: ğŸ“š Key Results
   :class: note

   * **Theorem 2.1:** Every NFA has an equivalent DFA
   * **Theorem 2.2:** The regular languages are closed under union, concatenation, and Kleene star
   * **Theorem 2.3:** A language is regular if and only if it is accepted by some finite automaton

----

**Next Steps**
==============

.. note::
   
   **ğŸš€ Ready for Regular Expressions?**
   
   In Chapter 3, we'll explore:
   * Regular expression syntax and semantics
   * Equivalence between regular expressions and finite automata
   * Converting between representations
   * Pumping lemma for regular languages
   
   :doc:`Continue to Regular Expressions â†’ <regular_expressions>`

.. admonition:: Self-Check
   :class: important

   **Before proceeding, ensure you can:**
   
   * [ ] Draw DFAs and NFAs for given language descriptions
   * [ ] Execute automata on input strings step-by-step
   * [ ] Convert NFAs to equivalent DFAs systematically  
   * [ ] Prove that an automaton accepts a specific language
   
   **Need more practice?** Try the additional exercises in :doc:`solutions_manual`
